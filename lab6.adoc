= Лабораторна робота №6

== Тема: Розробка програм з використанням складних типів даних: двовимірних масивів та рядків

Мета роботи: оволодіння навичками складання програм з використанням двовимірних масивів та рядків за допомогою засобів мови Kotlin .

== Двовимірні масиви

Часто одного масиву недостатньо. У деяких випадках зручно використовувати двовимірні масиви. Візуально їх легко уявити у вигляді сітки. Типовий приклад - зал в кінотеатрі. Щоб знайти потрібне місце в залі кінотеатру, нам потрібно знати ряд і місце.

Двовимірний масив - це масив, який містить інші масиви.

Розглянемо приклад.
Створимо двовимірний масив 5х5 і заповнимо його нулями.

[source,kotlin]
----
// Створюємо двовимірний масив
var matrix = arrayOf<Array<Int>>()

// заповнюємо нулями
for (i in 0..4) {
    var array = arrayOf<Int>()
    for (j in 0..4) {
        array += 0
    }
    matrix += array
}

// виводимо дані масиву
for (array in cinema) {
    for (value in array) {
        print("$value ")
    }
   println()
}
----

В результаті отримаємо такий масив, що буде виведений на екран
----
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
----

Якщо розміри масиву відомі заздалегідь, можна створити масив і одразу заповнити його нулями (чи будь-якими іншими значеннями):

[source,kotlin]
----
val n = 5
val matrix = Array(n){ Array(n) { 0 } }
----

Нагадаємо, що іноді, коли елементами одновимірного масиву є примітивні значення (з мови Java), для підвищення швидкодії програми можна скористатись спеціальними типами масивів: IntArray, LongArray, DoubleArray, CharArray та ін.
Наприклад, попередній фрагмент можна переписати так:

[source,kotlin]
----
val n = 5
val matrix = Array(n){ IntArray(n) { 0 } }
----

Нагадаємо також, що в мові Kotlin дуже часто замість масивів використовуються списки.
При цьому треба мати на увазі, що списки List є незмінними, тобто значення, які будуть записані у відповідні елементи під час ініціалізації, змінити буде неможливо.
Списки також можуть бути двовимірними:

[source,kotlin]
----
val n = 5
val matrixOf0 = List(n){ List(n) { 0 } }
val mutableMatrix = List(n){ MutableList(n) {0} }
----

Також, можна комбінувати масиви і списки, наприклад, створити список масивів:

[source,kotlin]
----
val n = 5
val matrix = List(n){ IntArray(n) { 0 } }
----

__**Примітка**. В подальшому там, де використовується термін "двовимірний масив", мається на увазі одна з показаних вище конструкцій.
__

Для отримання доступу до елемента двовимірного масиву, треба вказати два індекси: індекс у зовнішньому масиві (найчастіше, це - номер рядка) та індекс внутрішнього масиву (найчастіше, це - номер стовпця).

Наприклад:

[source,kotlin]
----
matrix[2][1] = 100 // елементу з індексами 2,1 присвоюємо значення 100
// заповнення діагональних елементів матриці одиницями
for (i in matrix.indices) {
    for (j in matrix[i].indices) {
        matrix[i][j] = 1
    }
}
----

Розглянемо більш складний приклад. Створимо масив, заповнюючи елементи, що розташовуються на головній діагоналі одиницями, а інші - нулями. Звісно, для цього можна було скористатись кодами, наведеними у попередніх прикладах, проте існує більш компактний спосіб зробити це, використовуючи ініціалізатори:

[source,kotlin]
----
// змінна n - розмір матриці, визначена раніше
val matrix = Array(n){ row -> IntArray(n) { col -> if (row == col) 1 else 0 } }
----

== Рядки


== Завдання 6.1
Заповнити двовимірний масив згідно правила заданого рисунком

_Розмір масиву вводити з клавіатури. Всі елементи, що потрапляють до зафарбованої області дорівнюють 1, всі інші - дорівнюють 0_

Після заповнення, масив обов'язково вивести на екран

=== Варіант 1
image::pic/image001.png[]

=== Варіант 2
image::pic/image002.png[]
&nbsp;

<<<

=== Варіант 3
image::pic/image003.png[]
&nbsp;

=== Варіант 4
image::pic/image004.png[]
&nbsp;

=== Варіант 5
image::pic/image005.png[]
&nbsp;

<<<
=== Варіант 6
image::pic/image006.png[]
&nbsp;

=== Варіант 7
image::pic/image007.png[]
&nbsp;

=== Варіант 8
image::pic/image008.png[]
&nbsp;

<<<
=== Варіант 9
image::pic/image009.png[]
&nbsp;

=== Варіант 10
image::pic/image010.png[]
&nbsp;

=== Варіант 11
image::pic/image011.png[]
&nbsp;


<<<
=== Варіант 12
image::pic/image012.png[]
&nbsp;

=== Варіант 13
image::pic/image013.png[]
&nbsp;

=== Варіант 14
image::pic/image014.png[]
&nbsp;


<<<
=== Варіант 15
image::pic/image015.png[]
&nbsp;

=== Варіант 16
image::pic/image016.png[]
&nbsp;

=== Варіант 17
image::pic/image017.png[]
&nbsp;


<<<
=== Варіант 18
image::pic/image018.png[]

=== Варіант 19
image::pic/image019.png[]

=== Варіант 20
image::pic/image020.png[]


<<<
== Завдання 6.2
Згідно варіанту з завдання 6.1 знайти суму та середнє арифметичне значення елементів зафарбованої частини масиву

_Для виконання завдання попередньо заповнити масив випадковими цілими числами з проміжку від -50 до 50_

Результати обчислень вивести на екран

== Завдання 6.3
Скласти програму для виконання наступних дій і виконати її в середовищі програмування.
_У всіх завданнях вважати, що рядок може містити лише літери, цифри та знаки пробілу. Слово - послідовність символів, що не містить пробілів._

=== Варіанти 1-3
Визначення кількості слів у рядку

=== Варіанти 4-6
Вилучення усіх цифр в рядку

=== Варіанти 7-9
Інвертування символів у рядку

=== Варіанти 10-12
Визначення кількості цифр у рядку

=== Варіанти 13-15
Визначення слова з найменшою кількістю літер в рядку

=== Варіанти 16-18
Визначення кількості чисел у рядку

=== Варіанти 19-21
Визначення слова з найбільшою кількістю літер у рядку

=== Варіанти 22-24
Заміна усіх великих букв в рядку на малі

=== Варіанти 25-27
Вилучення зайвих символів «пробіл» в рядку (виконати заміну кожної послідовності з двох, або більше «пробілів» на один)

=== Варіанти 28-30
Заміна усіх рядкових (малих) букв в рядку на заголовні (великі)


